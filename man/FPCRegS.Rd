% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FPCRegS.R
\name{FPCRegS}
\alias{FPCRegS}
\title{Function for performing functonal linear regression where the covariates are functions X1(t1),X2(t2),.. and the response is a function Y(t_y).}
\usage{
FPCRegS(vars, varsOptns = NULL, isNewSub = NULL,
  methodSelect = list(method = "FVE", FVEThreshold = 0.95, NumberOfBasis =
  NULL), interval = c(0, 1))
}
\arguments{
\item{vars}{A list of input functional covariates with name of "X1", "X2",.. and a functional response with name "Y". Each field should have two fields: 'Lt', a list (sparse) or a matrix (Dense) specifying the time of observations, and 'Ly', a list (Sparse) or a matrix (Dense) of the observations.}

\item{varsOptns}{A list of options named by "X1", "X2",..."Y". Each filed specify the paramaters that control the corresponding variables. (default: see details of FPCA())}

\item{isNewSub}{A 1*n vector of 0s or 1s, where n is the total count of subjects. 0 denotes the corresponding subject is only used for estimation and 1 denotes the corresponding subject is only used for prediction. (default: 0's)}

\item{methodSelect}{The method used for selecting the number of principal components of functional predictors X's used in functional regression , including 'AIC', 'BIC' and 'FVE'. (default: "AIC")}

\item{interval}{A length 2 vector indicate the support grid of the functional covariate, default to be c(0,1)}
}
\value{
A list containing the following fields:
\item{BetaList}{A list with fields of estimated beta_XiY(s,t) defiend on [range(Xi),range(Y)]}
\item{R2}{Functional R-square.}
\item{predictions}{predict value}
\item{NOC}{number of component chosen here}
\item{EigenV}{FPC eigen value}
\item{EigenF}{FPC eigen function (generated from large function)}
}
\description{
Function for performing functonal linear regression where the covariates are functions X1(t1),X2(t2),.. and the response is a function Y(t_y).
}
\examples{
set.seed(1000)
#Model: E(Y(t)|X) = int(beta(s,t)*X(s))
n <- 200 #number of subjects
ngrids <- 51 #number of grids in [0,1] for X(s)
ngridt <- 101 #number of grids in [0,1] for Y(t)
grids <- seq(0, 1, length.out=ngrids) #regular grids in [0,1] for X(s)
gridt <- seq(0, 1, length.out=ngridt) #regular grids in [0,1] for Y(t)
#generate X
#{1, sqrt(2)*sin(2*pi*s), sqrt(2)*cos(2*pi*t)} are used to generate X.
eigenFun <- list(function(s){1 + 0 * s},function(s){sqrt(2) * sin(2*pi*s)},function(s){sqrt(2) * cos(2*pi*s)})
sig <- matrix(c(1.5, 0.0, 0.0, 0.9, -.5, 0.1,
                0.0, 1.2, 0.0, -.3, 0.8, 0.4,
                0.0, 0.0, 1.0, 0.4, -.3, 0.7,
                0.9, -.3, 0.4, 2.0, 0.0, 0.0,
                -.5, 0.8, -.3, 0.0, 1.5, 0.0,
                0.1, 0.4, 0.7, 0.0, 0.0, 1.0),
                nrow=6,ncol=6)
scoreX <- MASS::mvrnorm(n,mu=rep(0,6),Sigma=sig)
scoreX1 <- scoreX[,1:3]
scoreX2 <- scoreX[,4:6]
basisX1 <- sapply(eigenFun,function(x){x(grids)})
latentX1 <- scoreX1 \%*\% t(basisX1)
measErrX1 <- sqrt(0.03) * matrix(rnorm(n * ngrids), n, ngrids) #0.01 is sigma^2.
denseX1 <- latentX1 + measErrX1
basisX2 <- sapply(eigenFun,function(x){x(grids)})
latentX2 <- scoreX2 \%*\% t(basisX2)
measErrX2 <- sqrt(0.03) * matrix(rnorm(n * ngrids), n, ngrids) #0.01 is sigma^2.
denseX2 <- latentX2 + measErrX2
#generate Y
#beta(s, t) <- sin(2 * pi * s)*cos(2 * pi * t)
betaEigen <- list(function(s){1 + 0 * s},function(s){sqrt(2) * sin(2*pi*s)},function(s){sqrt(2) * cos(2*pi*s)})
basisY <- c(1,0.1,0.01)
latentY <- scoreX1 \%*\% basisY + scoreX2 \%*\% basisY
measErrY <- sqrt(0.01) * rnorm(n) #0.01 is sigma^2
denseY <- latentY + measErrY
#======Dense data===============================================
timeX <- t(matrix(rep(grids, n),length(grids), n))
denseVars <- list(X1 = list(Ly = denseX1, Lt = timeX),
                  X2 = list(Ly = denseX2, Lt = timeX),
                  Y= denseY)
resuDense <- FPCRegS(denseVars) 
#======Sparse data===============================================
sparsity = 5:8
sparseX1 <- Sparsify(denseX1, grids, sparsity)
sparseX2 <- Sparsify(denseX2, grids, sparsity)
sparseVars <- list(X1 = sparseX1, X2 = sparseX2, Y = denseY)
resuSparse <- FPCRegS(sparseVars, methodSelect=list(method = "FVE",FVEThreshold = 0.9)) #or resuSparse <- FPCReg(vars = sparseVars,varsOptns = list(X1=list(userBwCov = 0.03)))
MixedVars <- list(X1 = sparseX1, X2 = list(Ly = denseX2, Lt = timeX), Y = denseY)
TestRes3 = FPCRegS(MixedVars)
basisX2 <- sapply(eigenFun,function(x){x(grids)})
latentX2 <- scoreX2 \%*\% t(basisX2)
measErrX2 <- sqrt(0.03) * matrix(rnorm(n * ngrids), n, ngrids) #0.01 is sigma^2.
denseX2 <- latentX2 + measErrX2

#generate Y
#beta(s, t) <- sin(2 * pi * s)*cos(2 * pi * t)
betaEigen <- list(function(s){1 + 0 * s},function(s){sqrt(2) * sin(2*pi*s)},function(s){sqrt(2) * cos(2*pi*s)})
basisY <- c(1,0.1,0.01)
latentY <- scoreX1 \%*\% basisY + scoreX2 \%*\% basisY
measErrY <- sqrt(0.01) * rnorm(n) #0.01 is sigma^2
denseY <- latentY + measErrY

#======Dense data===============================================
timeX <- t(matrix(rep(grids, n),length(grids), n))
denseVars <- list(X1 = list(Ly = denseX1, Lt = timeX),
                  X2 = list(Ly = denseX2, Lt = timeX),
                  Y= denseY)

resuDense <- FPCRegS(denseVars) 
#======Sparse data===============================================
sparsity = 5:8
sparseX1 <- Sparsify(denseX1, grids, sparsity)
sparseX2 <- Sparsify(denseX2, grids, sparsity)
sparseVars <- list(X1 = sparseX1, X2 = sparseX2, Y = denseY)

resuSparse <- FPCRegS(sparseVars, methodSelect=list(method = "FVE",FVEThreshold = 0.9)) #or resuSparse <- FPCReg(vars = sparseVars,varsOptns = list(X1=list(userBwCov = 0.03)))
MixedVars <- list(X1 = sparseX1, X2 = list(Ly = denseX2, Lt = timeX), Y = denseY)
TestRes3 = FPCRegS(MixedVars)
}
\references{
\cite{Yao, F., Mueller, H.G., Wang, J.L. "Functional Linear Regression Analysis for Longitudinal Data." Annals of Statistics 33, (2005): 2873-2903.}
}
